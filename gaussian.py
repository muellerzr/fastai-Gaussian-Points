# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/23_Gaussian_Points.ipynb (unless otherwise specified).

__all__ = ['get_points', 'TensorMaps', 'GaussianBlock']

# Cell
from fastai2.vision.all import *

# Cell
def _check_corners(p, feat_stride, heatmap_size, tmp_size, is_bool=True):
  "Checks to ensure the point can be on the heatmap"
  mu_x = int(p[0] / feat_stride[0] + .5)
  mu_y = int(p[1] / feat_stride[1] + .5)
  ul = [int(mu_x - tmp_size), int(mu_y - tmp_size)]
  br = [int(mu_x + tmp_size + 1), int(mu_y + tmp_size + 1)]
  if ul[0] >= heatmap_size[0] or ul[1] >= heatmap_size[1] \
          or br[0] < 0 or br[1] < 0:
          return False
      #targ[i] = 0
  return True if is_bool else [ul, br]

# Cell
def _build_heatmap(heatmap_size, ul, br):
  "Builds gaussian heatmap from corners"
  g_x = max(0, -ul[0]), min(br[0], heatmap_size[0]) - ul[0]
  g_y = max(0, -ul[1]), min(br[1], heatmap_size[1]) - ul[1]

  img_x = max(0, ul[0]), min(br[0], heatmap_size[0])
  img_y = max(0, ul[1]), min(br[1], heatmap_size[1])

  return g_x, g_y, img_x, img_y

# Cell
def _build_targ(targ, g, g_x, g_y, img_x, img_y):
  "Builds target from adjusted gaussian heatmap"
  targ[img_y[0]:img_y[1], img_x[0]:img_x[1]] = g[g_y[0]:g_y[1], g_x[0]:g_x[1]]
  return targ

# Cell
def _generate_targs(points:TensorPoint, sig:int=1, img_size=None):
  "Generates a gaussian heatmap from `p` points"
  tmp_size = sig*3
  heatmap_size = (img_size[0]//4, img_size[1]//4)
  feat_stride = np.asarray(img_size)/np.asarray(heatmap_size)
  targ = np.zeros((len(points),
                   heatmap_size[1],
                   heatmap_size[0]))
  for i, p in enumerate(points):
    if not np.array_equal(p, [-1,-1]):
      if not _check_corners(p, feat_stride, heatmap_size, tmp_size):
        targ[i] = 0
      else:
        size = 2*tmp_size+1
        x = np.arange(0, size, 1, np.float32)
        y = x[:, np.newaxis]
        x0 = y0 = size // 2
        g = np.exp(- ((x - x0) ** 2 + (y - y0) ** 2) / (2 * sig ** 2))
        ul, br = _check_corners(p, feat_stride, heatmap_size, tmp_size, False)
        g_x, g_y, img_x, img_y = _build_heatmap(heatmap_size, ul, br)
        targ[i] = _build_targ(targ[i], g, g_x, g_y, img_x, img_y)

  return targ

# Cell
def get_points(x:tensor, size:array):
  "Extract a point from a heatmap and convert it"
  boxes = np.asarray([[0,0,size[1], size[0]]])
  pts = []
  for j, pnt in enumerate(x):
    pt = np.unravel_index(np.argmax(pnt), (size[0]//4, size[1]//4))
    y1 = int(pt[0] * 1. / (size[0]//4) * (boxes[0][3] - boxes[0][1]) + boxes[0][1])
    x1 = int(pt[1] * 1. / (size[1]//4) * (boxes[0][2] - boxes[0][0]) + boxes[0][0])
    pts.append([x1,y1])
  return pts

# Cell
class TensorMaps(Transform):
  "Convert points into heatmaps"
  order = 99
  def __init__(self, sig=1): self.sig=sig

  def encodes(self, x:TensorPoint):
    x = np.array(x.get_meta('img_size'))
    x = (x+1)*x/2
    return _generate_targs(x, self.sig, x.get_meta('img_size'))

# Cell
GaussianBlock = TransformBlock(type_tfms=TensorPoint.create, item_tfms=[PointScaler, TensorMaps])